---
title: 游戏引擎开发
date: 2025-9-7 11:35:23
tags: 
    - C#
    - Unity
    - 游戏开发
categories: 
    - 计算机
    - 游戏开发
    - unity
---

前言：
本文章为游戏引擎开发的基础知识大纲，是本人学习后的知识总结，如有遗漏不足，欢迎指正，具体内容请移步相关文档及链接：

文档链接: [游戏网络编程](https://www.mubu.com/doc/2FLf9VC-W9L)

【如果遇到密码，统一为：1230】


下面内容为文章目录，可以先预览后再决定是否详细查看文档



#### **一、游戏网络编程**  
1.1 同步Echo程序  
　1.1.1 环境配置与程序创建  
　　1.1.1.1 .NET SDK安装与验证  
　　1.1.1.2 创建EchoServer控制台应用  
　1.1.2 套接字通信实现  
　　1.1.2.1 TCP/IP终结点（IPEndPoint）  
　　1.1.2.2 客户端Socket连接与数据传输  
　　1.1.2.3 服务器Socket监听与响应  
　1.1.3 同步阻塞问题  
　　1.1.3.1 单客户端处理限制  
　　1.1.3.2 同步API的性能瓶颈  

1.2 网络编程基础  
　1.2.1 Socket概念与通信模型  
　　1.2.1.1 C/S架构（客户端-服务器模型）  
　　1.2.1.2 Socket组成（IP地址与端口号）  
　　1.2.1.3 通信流程（监听、连接、数据交换）  
　1.2.2 Socket类型与协议  
　　1.2.2.1 流式套接字（TCP协议）  
　　1.2.2.2 数据报套接字（UDP协议）  
　　1.2.2.3 原始套接字（底层协议操作）  

1.3 异步Echo程序  
　1.3.1 非阻塞通信实现  
　　1.3.1.1 客户端异步发送文本  
　　1.3.1.2 服务器多客户端并发处理  
　1.3.2 Unity客户端集成  
　　1.3.2.1 UI设计与异步事件绑定  

1.4 异步与多路复用  
　1.4.1 I/O模型分类  
　　1.4.1.1 阻塞式I/O  
　　1.4.1.2 非阻塞式I/O（轮询机制）  
　　1.4.1.3 I/O复用（Select与Poll）  
　　1.4.1.4 异步I/O（内核通知完成）  
　　1.4.1.5 信号驱动式I/O（SIGIO）  
　1.4.2 异步编程实现  
　　1.4.2.1 `async`与`await`关键字  
　　1.4.2.2 `Task<T>`与异步操作管理  
　　1.4.2.3 异步操作性能优化  

---

#### **二、TCP数据收发问题与解决方案**  
2.1 粘包与拆包问题  
　2.1.1 粘包问题分析  
　　2.1.1.1 原因（Nagle算法、缓冲区累积）  
　　2.1.1.2 实验模拟与现象复现  
　2.1.2 拆包问题分析  
　　2.1.2.1 原因（MSS限制、网络拥塞）  
　　2.1.2.2 实验模拟与现象复现  
　2.1.3 解决方案  
　　2.1.3.1 长度信息法（头部添加长度字段）  
　　2.1.3.2 固定长度法（填充补齐数据包）  
　　2.1.3.3 特殊字符分隔法（边界标识符）  

2.2 数据丢失与重传机制  
　2.2.1 数据丢失原因  
　　2.2.1.1 网络拥塞与缓冲区溢出  
　　2.2.1.2 操作系统发送机制限制  
　2.2.2 应用层解决方案  
　　2.2.2.1 数据校验与队列管理  
　　2.2.2.2 重传机制实现（ByteArray封装）  

2.3 大小端问题  
　2.3.1 大小端存储差异  
　　2.3.1.1 大端模式与小端模式定义  
　　2.3.1.2 数值存储示例（如258的存储）  
　2.3.2 兼容性处理  
　　2.3.2.1 强制小端编码转换  
　　2.3.2.2 系统检测与动态调整  

2.4 高效数据接收  
　2.4.1 性能问题分析  
　　2.4.1.1 `Array.Copy`的时间复杂度问题  
　2.4.2 优化方案  
　　2.4.2.1 `ByteArray`动态缓冲区设计  
　　2.4.2.2 偏移量管理（`readIdx`与`writeIdx`）  

---

#### **三、C#语言核心机制**  
3.1 委托（Delegate）  
　3.1.1 委托定义与使用  
　　3.1.1.1 委托声明与方法绑定  
　　3.1.1.2 实例化方式（new、匿名函数、Lambda）  
　3.1.2 多播委托  
　　3.1.2.1 委托链（+=与-=操作）  
　　3.1.2.2 异常处理与调用列表（`GetInvocationList`）  

3.2 抽象类与接口  
　3.2.1 抽象类（Abstract Class）  
　　3.2.1.1 定义与继承规则  
　　3.2.1.2 抽象方法实现（`override`关键字）  
　3.2.2 接口（Interface）  
　　3.2.2.1 接口与抽象类的区别  
　　3.2.2.2 多重继承与实现约束  

3.3 反射机制  
　3.3.1 反射核心类  
　　3.3.1.1 `Type`类（类型信息获取）  
　　3.3.1.2 `Assembly`、`MethodInfo`、`PropertyInfo`  
　3.3.2 反射应用场景  
　　3.3.2.1 动态对象创建与调用  
　　3.3.2.2 元数据操作（字段、方法、属性）  

---

#### **四、Unity网络框架与游戏开发**  
4.1 游戏网络框架设计  
　4.1.1 客户端框架  
　　4.1.1.1 消息队列与事件驱动  
　　4.1.1.2 网络模块与UI模块解耦  
　4.1.2 服务器端框架  
　　4.1.2.1 高并发处理（异步Socket）  
　　4.1.2.2 数据持久化与缓存策略  

4.2 Unity网络框架集成  
　4.2.1 Netcode for GameObjects  
　　4.2.1.1 基础组件与同步机制  
　　4.2.1.2 大乱斗游戏案例实现  
　4.2.2 多玩家同步优化  
　　4.2.2.1 状态同步与插值算法  
　　4.2.2.2 延迟补偿与预测技术  

4.3 VR游戏开发（VR Rowling）  
　4.3.1 场景与交互设计  
　　4.3.1.1 VRTK工具集成  
　　4.3.1.2 运动控制与物理反馈  
　4.3.2 动画与特效  
　　4.3.2.1 角色动画状态机  
　　4.3.2.2 粒子系统与光影效果  

---

#### **五、游戏实现模块**  
5.1 游戏关卡与场景  
　5.1.1 场景切换逻辑  
　　5.1.1.1 异步加载与进度管理  
　　5.1.1.2 资源释放与内存优化  
　5.1.2 关卡设计  
　　5.1.2.1 敌人AI行为树  
　　5.1.2.2 动态难度调整  

5.2 游戏角色与动画  
　5.2.1 角色控制  
　　5.2.1.1 输入处理（键盘、手柄、VR设备）  
　　5.2.1.2 物理碰撞与运动模拟  
　5.2.2 动画系统  
　　5.2.2.1 骨骼动画与混合树  
　　5.2.2.2 动画事件与状态切换  

5.3 游戏特效与音效  
　5.3.1 特效实现  
　　5.3.1.1 粒子系统与Shader效果  
　　5.3.1.2 屏幕后处理（Bloom、Motion Blur）  
　5.3.2 音效管理  
　　5.3.2.1 背景音乐与动态音效  
　　5.3.2.2 空间音效（3D音频定位）  

